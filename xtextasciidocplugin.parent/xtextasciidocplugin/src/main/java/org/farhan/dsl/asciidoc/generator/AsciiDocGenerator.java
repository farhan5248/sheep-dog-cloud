/*
 * generated by Xtext 2.36.0
 */
package org.farhan.dsl.asciidoc.generator;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;

import org.eclipse.emf.ecore.resource.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.resource.SaveOptions;
import org.farhan.dsl.asciidoc.LanguageAccessImpl;
import org.farhan.dsl.common.*;
import org.farhan.dsl.asciidoc.asciiDoc.TestStepContainer;
import org.farhan.dsl.asciidoc.asciiDoc.TestSuite;
import org.farhan.dsl.asciidoc.asciiDoc.TestStep;

/**
 * Generates code from your model files on save.
 * 
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
public class AsciiDocGenerator extends AbstractGenerator {

	private static final Logger logger = LoggerFactory.getLogger(AsciiDocGenerator.class);

	@Override
	public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
		logger.debug("Entering doGenerate for resource: {}", resource != null ? resource.getURI() : "null");
		// Automatic generation disabled - use command-based generation instead
		// Generation logic moved to generateFromResource() method
		// The reason is that I didn't want to generate code until the user was ready
		// to do so.
		logger.debug("Exiting {}", "doGenerate");
	}

	public static void generateFromResource(final Resource resource) {
		logger.info("Entering generateFromResource for resource: {}", resource != null ? resource.getURI() : "null");
		try {
			if (resource == null || resource.getContents().isEmpty()) {
				logger.warn("Resource is null or has no contents");
				return;
			}

			if (resource.getContents().get(0) instanceof TestSuite) {
				TestSuite theTestSuite = (TestSuite) resource.getContents().get(0);
				logger.debug("Processing TestSuite: {}", theTestSuite.getName());

				for (TestStepContainer scenario : theTestSuite.getTestStepContainerList()) {
					logger.debug("Processing scenario: {}", scenario.getName());
					for (TestStep step : scenario.getTestStepList()) {
						logger.debug("Processing step: {}", step.getName());
						doGenerateFromTestStep(step, null);
					}
				}
			} else {
				logger.warn("Resource content is not a TestSuite: {}", resource.getContents().get(0).getClass());
			}
			logger.debug("Exiting {}", "generateFromResource");
		} catch (Exception e) {
			logger.error("Failed to generate from resource {}: {}", resource != null ? resource.getURI() : "null",
					e.getMessage(), e);
		}
	}

	public static LanguageAccessImpl doGenerateFromTestStep(TestStep step, OutputStream os) {
		// TODO make another method, one that returns a string vs one that writes to a
		// file. The quickfix one shouldn't write to the file so undo the changes to save
		logger.debug("Entering doGenerateFromTestStep for step: {}", step != null ? step.getName() : "null");
		try {
			logger.info("Calling LanguageHelper.generate with step: {}", step.getName());
			LanguageAccessImpl la = new LanguageAccessImpl(step, os);
			LanguageHelper.generate(la,
					SaveOptions.newBuilder().format().getOptions().toOptionsMap());
			logger.debug("Exiting {}", "doGenerateFromTestStep");
			return la;
		} catch (Exception e) {
			logger.error("Generation failed for step '{}': {}", step != null ? step.getName() : "null", e.getMessage(),
					e);
		}
		return null;
	}

}
