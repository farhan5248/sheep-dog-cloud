/*
 * generated by Xtext 2.36.0
 */
package org.farhan.dsl.asciidoc.validation;

import java.io.PrintWriter;
import java.io.StringWriter;

import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.farhan.dsl.asciidoc.LanguageAccessImpl;
import org.farhan.dsl.asciidoc.asciiDoc.TestStepContainer;
import org.farhan.dsl.asciidoc.asciiDoc.Cell;
import org.farhan.dsl.asciidoc.asciiDoc.AsciiDocPackage;
import org.farhan.dsl.asciidoc.asciiDoc.TestSuite;
import org.farhan.dsl.asciidoc.asciiDoc.TestStep;
import org.farhan.dsl.asciidoc.asciiDoc.Table;
import org.farhan.dsl.common.*;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class AsciiDocValidator extends AbstractAsciiDocValidator {

	public static final String INVALID_NAME = "invalidName";
	public static final String INVALID_HEADER = "invalidHeader";
	public static final String INVALID_STEP_TYPE = "invalidStepType";
	public static final String MISSING_STEP_DEF = "missingStepDefinition";
	public static final String MISSING_COMPONENT = "missingInitialComponent";
	public static final String INVALID_PATH = "invalidpath";

	@Check(CheckType.EXPENSIVE)
	public void checkFeature(TestSuite feature) {
		// TODO validate that feature file name and feature name are the same.
		if (!Character.isUpperCase(feature.getName().charAt(0))) {
			warning("TestSuite name should start with a capital", AsciiDocPackage.Literals.MODEL__NAME, INVALID_NAME);
		}

		String path = feature.eResource().getURI().path();
		if (!path.contains("src/test/resources/asciidoc/specs/")) {
			error("The resource " + path + " isn't in a src/test/resources/asciidoc/specs directory.",
					AsciiDocPackage.Literals.MODEL__NAME, INVALID_PATH);
		}
	}

	@Check(CheckType.NORMAL)
	public void checkScenario(TestStepContainer abstractScenario) {
		if (!Character.isUpperCase(abstractScenario.getName().charAt(0))) {
			warning("Scenario name should start with a capital", AsciiDocPackage.Literals.TEST_STEP_CONTAINER__NAME,
					INVALID_NAME);
		}
	}

	@Check(CheckType.FAST)
	public void checkStepName(TestStep step) {
		try {
			LanguageAccessImpl lang = new LanguageAccessImpl(step);
			if (step.getName() != null) {
				String problems = LanguageHelper.validateError(lang);
				if (!problems.isEmpty()) {
					error(problems, AsciiDocPackage.Literals.TEST_STEP__NAME, INVALID_NAME);
				}

				problems = LanguageHelper.validateWarning(lang);
				if (!problems.isEmpty()) {
					warning(problems, AsciiDocPackage.Literals.TEST_STEP__NAME, MISSING_STEP_DEF,
							getAlternateObjects(lang));
				}
			}
		} catch (Exception e) {
			error(logError(e, step.getName()), AsciiDocPackage.Literals.TEST_STEP__NAME, INVALID_NAME);
		}
	}

	@Check(CheckType.FAST)
	public void checkStepTableName(Table stepTable) {
		// TODO Add table column row validation, each row should have the max number of
		// columns
		// TODO make tests for this
		if (stepTable.getRowList() != null) {
			if (stepTable.getRowList().size() > 0) {
				for (Cell header : stepTable.getRowList().get(0).getCellList()) {
					if (!Character.isUpperCase(header.getName().charAt(0))) {
						warning("Table header names should start with a capital: " + header.getName(),
								AsciiDocPackage.Literals.TABLE__ROW_LIST, INVALID_HEADER, header.getName());
					}
				}
			}
		}
	}

	public String[] getAlternateObjects(LanguageAccessImpl la) throws Exception {
		Object[] alternateProposals = LanguageHelper.getAlternateObjects(la);
		String[] alternates = new String[alternateProposals.length];
		for (int i = 0; i < alternates.length; i++) {
			alternates[i] = alternateProposals[i].toString();
		}
		return alternates;
	}

	private String logError(Exception e, String name) {
		// TODO inject the logger instead
		System.out.println("There was a problem listing directories for: " + name);
		StringWriter sw = new StringWriter();
		e.printStackTrace(new PrintWriter(sw));
		System.out.println(sw.toString());
		return sw.toString();
	}
}
